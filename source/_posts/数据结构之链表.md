---
title: 数据结构之链表
date: 2017-09-07 15:59:54
tags: [数据结构,C++]
---

链表插入、删除元素效率高。
<!-- more -->

## 链表结构

<center>
	<img src="./sinple.png" width="500px"></img>
</center>
<center>
图1 单链表结构
</center>

<center>
	<img src="./cicle.png" width="500px"></img>
</center>
<center>
图2 循环链表结构
</center>

<center>
	<img src="./double.png" width="300px"></img>
</center>
<center>
图3 双链表结构
</center>

<center>
	<img src="./static.png" width="300px"></img>
</center>
<center>
图4 静态链表结构
</center>



## 单链表的编码实现
Node.h

	```c++
	#pragma once
	class Node
	{
	public:
		int data;//数据域
		Node *next;//指针域
		void printNode();//打印数据域
	};
	```

Node.cpp

	```c++
	#include "Node.h"
	#include<iostream>
	using namespace std;
	void Node::printNode()
	{
		cout<<data<<endl;
	}
	```

List.h

	```c++
	#pragma once
	#include <stdio.h>
	#include "Node.h"
	//单链表 int 
	class List
	{
	public:
		List();//创建链表
		~List();//销毁链表
		void ClearList();//清空链表
		bool ListEmpty();//判断链表是否为空
		int ListLength();//返回链表的长度
		bool GetElem(int i,Node *pNode);//获取指定位置的节点
		int LocateElem(Node *pNode);//定位节点
		bool PriorElem(Node *pCurrentNode,Node *pPreNode);//获取指定节点的前驱
		bool NextElem(Node *pCurrentNode,Node *pNextElem);//获取指定节点的的后继
		void ListTraverse();//遍历链表
		bool ListInsert(int i,Node *pNode);//插入节点
		bool ListDelete(int i,Node *pNode);//删除节点
		bool ListInsertHead(Node *pNode);//在链表头插入节点
		bool ListInsertTail(Node *pNode);//在链表尾插入节点
	private:
		Node *m_pList;//链表的头结点
		int m_iLenght;//数组中节点的个数
	};
	```

List.cpp

	```c++
	#include "List.h"
	//构造函数
	List::List()
	{
		//创建头节点
		m_pList=new Node;
		m_pList->data=0;
		m_pList->next=NULL;
		m_iLenght=0;
	}
	//析构函数
	List::~List()
	{
		ClearList();
		delete m_pList;
		m_pList=NULL;
	}
	//清空链表
	void List::ClearList()
	{
		Node *currentNode = m_pList->next;
		while (currentNode!=NULL)
		{
			Node *temp=currentNode->next;
			delete currentNode;
			currentNode=temp;
		}
		m_pList->next=NULL;
	}
	//判断链表是否为空
	bool List::ListEmpty()
	{
		return m_iLenght==0?true:false;
	}
	//返回链表的长度
	int List::ListLength()
	{
		return m_iLenght;
	}
	//在链表头插入节点
	bool List::ListInsertHead(Node *pNode)
	{
		Node *temp=m_pList->next;
		Node *newNode=new Node;//一定要从堆中申请内存
		if(newNode==NULL)
		{
			return false;
		}
		newNode->data=pNode->data;
		m_pList->next=newNode;
		newNode->next=temp;
		m_iLenght++;
		return true;
	}
	//在链表尾插入节点
	bool List::ListInsertTail(Node *pNode)
	{
		Node *currentNode=m_pList;
		//找最后一个节点
		while (currentNode->next!=NULL)
		{
			currentNode=currentNode->next;
		}
		Node *newNode=new Node;//一定要从堆中申请内存
		if(newNode==NULL)
		{
			return false;
		}
		newNode->data=pNode->data;
		newNode->next=NULL;
		currentNode->next=newNode;
		m_iLenght++;
		return true;
	}
	//插入节点
	bool List::ListInsert(int i,Node *pNode)
	{
		if (i<0||i>m_iLenght)
		{
			return false;
		}
		Node *currentNode=m_pList;
		//找到第 i 个节点
		for (int k=0;k<i;k++)
		{
			currentNode=currentNode->next;
		}
		Node *newNode=new Node;//一定要从堆中申请内存
		if(newNode==NULL)
		{
			return false;
		}
		newNode->data=pNode->data;
		newNode->next=currentNode->next;
		currentNode->next=newNode;
		m_iLenght++;
		return true;
	}
	//删除节点
	bool List::ListDelete(int i,Node *pNode)
	{
		if (i<0||i>=m_iLenght)
		{
			return false;
		}
		Node *currentNode=m_pList;
		Node *currentNodeBefore=NULL;
		//找到第 i 个节点,和第 i 个节点的前一个节点
		for (int k=0;k<=i;k++)
		{
			currentNodeBefore=currentNode;
			currentNode=currentNode->next;
		}
		currentNodeBefore->next=currentNode->next;
		pNode->data=currentNode->data;
		delete currentNode;
		currentNode=NULL;
		m_iLenght--;
		return true;
	}
	//获取指定位置的节点
	bool List::GetElem(int i,Node *pNode)
	{
		if (i<0||i>=m_iLenght)
		{
			return false;
		}
		Node *currentNode=m_pList;
		//找到第 i 个节点。
		for (int k=0;k<=i;k++)
		{
			currentNode=currentNode->next;
		}
		pNode->data=currentNode->data;
		return true;
	}
	//定位节点
	int List::LocateElem(Node *pNode)
	{
		Node *currentNode=m_pList;
		int count = 0;
		//从头遍历节点
		while (currentNode->next!=NULL)
		{
			currentNode=currentNode->next;
			if (currentNode->data==pNode->data)
			{
				return count;
			}
			count++;
		}
		return -1;
	}
	//获取指定节点的前驱
	bool List::PriorElem(Node *pCurrentNode,Node *pPreNode)
	{
		Node *currentNode=m_pList;
		Node *currentNodeBefore=NULL;
		//从头遍历节点,获取指定节点的前驱
		while (currentNode->next!=NULL)
		{
			currentNodeBefore=currentNode;
			currentNode=currentNode->next;
			if (currentNode->data==pCurrentNode->data)
			{
				//如果前驱为第一个节点，也返回 false
				if (currentNodeBefore==m_pList)
				{
					return false;
				}
				pPreNode->data=currentNodeBefore->data;
				return true;
			}
		}
		return false;
	}
	//获取指定节点的的后继
	bool List::NextElem(Node *pCurrentNode,Node *pNextElem)
	{
		Node *currentNode=m_pList;
		//从头遍历节点
		while (currentNode->next!=NULL)
		{
			currentNode=currentNode->next;
			if (currentNode->data==pCurrentNode->data)
			{
				//如果前驱为第一个节点，也返回 false
				if (currentNode->next==NULL)
				{
					return false;
				}
				pNextElem->data=currentNode->next->data;
				return true;
			}
		}
		return false;
	}
	//遍历链表
	void List::ListTraverse()
	{
		Node *currentNode=m_pList;
		//从头遍历节点
		while (currentNode->next!=NULL)
		{
			currentNode=currentNode->next;
			currentNode->printNode();
		}
	}
	```
测试 demo.cpp

	```c++
	#include <stdlib.h>
	#include <iostream>
	#include "Node.h"
	#include "List.h"
	using namespace std;
	int main(void)
	{
		List *pList=new List();
		Node node1;
		node1.data=1;
		Node node2;
		node2.data=2;
		Node node3;
		node3.data=3;
		Node node4;
		node4.data=4;
		Node node5;
		node5.data=5;
		/*pList->ListInsertHead(&node1);
		pList->ListInsertHead(&node2);
		pList->ListInsertHead(&node3);
		pList->ListInsertHead(&node4);*/
		pList->ListInsertTail(&node1);
		pList->ListInsertTail(&node2);
		pList->ListInsertTail(&node3);
		pList->ListInsertTail(&node4);
		pList->ListTraverse();
		cout<<endl;
		pList->ListInsert(2,&node5);
		pList->ListTraverse();
		cout<<endl;
		Node temp;
		pList->ListDelete(2,&temp);
		pList->ListTraverse();
		cout<<endl;
		cout<<"temp:"<<temp.data<<endl;
		pList->ListTraverse();
		cout<<endl;
		cout<<"Lenght:"<<pList->ListLength()<<endl;;
		cout<<endl;
		pList->GetElem(3,&temp);
		cout<<"temp:"<<temp.data<<endl;
		cout<<endl;
		pList->PriorElem(&node3,&temp);
		cout<<"pre:"<<temp.data<<endl;
		pList->NextElem(&node3,&temp);
		cout<<"next:"<<temp.data<<endl;
		cout<<endl;
		delete pList;
		pList=NULL;
		system("pause");
		return 0;
	}
	```
