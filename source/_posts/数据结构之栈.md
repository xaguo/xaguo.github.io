---
title: 数据结构之栈
date: 2017-09-5 15:31:26
tags: [数据结构,C++]
---

栈：后进先出（LIFO:last in first out)的数据结构
<!-- more -->

<center>
	<img src="./stack.png" width="500px"></img>
</center>
<center>
图1 栈
</center>

空栈。栈底，栈顶。没有元素的时候，栈顶和栈底指向同一个元素，如果加入新元素，栈顶不断升高。取出数据时栈顶不断地降低。栈顶和栈底都称之为栈要素。

## 栈的编码实现

myStack.h
	
	```c++
	#pragma once
	class MyStack
	{
	public:
		MyStack(int size);      //分配内存初始化栈空间，设定栈容量，栈顶
		~MyStack();             //回收栈空间内存
		bool stackEmpty();      //判断栈是否为空
		bool stackFull();       //判断栈是否为满
		void clearStack();      //清空栈
		int stackLength();      //栈中元素的个数
		bool push(char elem);   //将元素压入栈中，栈顶上升
		bool pop(char &elem);   //将元素推出栈，栈顶下降
		void stackTraverse(bool isFromButtom);  //遍历栈中元素并输出
	private:
		char *m_pBuffer;        //栈空间指针
		int m_iTop;             //栈顶，栈中元素个数
		int m_iSize;            //栈容量
	};
	```

myStack.cpp

	```c++
	#include "Mystack.h"
	#include <iostream>
	using namespace std;
	MyStack::MyStack(int size)
	{
		m_iSize = size;
		m_pBuffer = new char[size];
		m_iTop = 0;
	}
	MyStack::~MyStack()
	{
		delete[]m_pBuffer;
		m_pBuffer = NULL;
	}
	bool MyStack::stackEmpty()
	{
		if (0==m_iTop)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool MyStack::stackFull()
	{
		if ( m_iTop == m_iSize)//>=
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	void MyStack::clearStack()
	{
		m_iTop = 0;//原栈中所有值无效
	}
	int MyStack::stackLength()
	{
		return m_iTop;
	}
	bool MyStack::push(char elem)//放入栈顶
	{
		if (stackFull())
		{
			return false;
		}
		m_pBuffer[m_iTop] = elem;
		m_iTop++;
		return true;
	}
	/*char MyStack::pop()
	{
	  if (stackEmpty())
	  {
	      throw 1;
	  }
	  else
	  {
	      m_iTop--;
	      return m_pBuffer[m_iTop];
	  }
	}*/
	bool MyStack::pop(char &elem)
	{
		if (stackEmpty())
		{
			return false;
		}
		m_iTop--;//因为入栈时做了++，使栈顶指向下一个空位置
		elem = m_pBuffer[m_iTop];
		return true;
	}
	void MyStack::stackTraverse(bool isFromButtom)
	{
		if (isFromButtom)
		{
			for (int i = 0; i < m_iTop; i++)
			{
				cout << m_pBuffer[i] << ",";
			}
		}
		else
		{
			for (int i = m_iTop - 1; i >= 0; i--)
			{
				cout << m_pBuffer[i] << ",";
			}
		}
		cout<<endl;
	}
	```

测试demo.cpp

	```c++
	#include "Mystack.h"
	#include <iostream>
	#include <stdlib.h>
	using namespace std;
	int main(void)
	{
		MyStack *pStack = new MyStack(5);
		//判空
		if (pStack->stackEmpty())
		{
			cout<<"栈为空"<<endl;
		}
		//元素压入栈
		pStack->push('h');//底
		pStack->push('e');
		pStack->push('l');
		pStack->push('l');
		pStack->push('o');//顶
		//从底部开始遍历栈
		pStack->stackTraverse(true);
		//判满
		if (pStack->stackFull())
		{
			cout<<"栈为满"<<endl;
		}
		//从顶部开始遍历栈
		pStack->stackTraverse(false);
		//元素出栈
		char elem = 5;
		pStack->pop(elem);
		cout << elem << endl;
		//从底部开始遍历栈
		pStack->stackTraverse(true);
		//栈中元素个数
		cout << pStack->stackLength() << endl;
		//清空栈
		pStack->clearStack();
		//栈中元素个数
		cout << pStack->stackLength() << endl;
		if (pStack->stackEmpty())
		{
			cout << "栈为空" << endl;
		}
		delete pStack;
		pStack = NULL;
		system("pause");
		return 0;
	}
	```

### 栈的类模板

MyStack.h

	```c++
	#pragma 
	#include <stdio.h>
	//改为类模板栈，可以适应更多的数据类型
	template <typename T>
	class MyStack
	{
	public:
		MyStack(int size);      //分配内存初始化栈空间，设定栈容量，栈顶
		~MyStack();             //回收栈空间内存
		bool stackEmpty();      //判断栈是否为空
		bool stackFull();       //判断栈是否为满
		void clearStack();      //清空栈
		int stackLength();      //栈中元素的个数
		bool push(T elem);   //将元素压入栈中，栈顶上升
		bool pop(T &elem);   //将元素推出栈，栈顶下降
		void stackTraverse(bool isFromButtom);  //遍历栈中元素并输出
	private:
		T *m_pBuffer;        //栈空间指针
		int m_iTop;             //栈顶，栈中元素个数
		int m_iSize;            //栈容量
	};
	//构造函数
	template <typename T>
	MyStack<T>::MyStack(int size)
	{
		m_iSize = size;
		m_pBuffer = new T[size];
		m_iTop = 0;
	}
	//析构函数
	template <typename T>
	MyStack<T>::~MyStack()
	{
		delete []m_pBuffer;
		m_pBuffer = NULL;
	}
	//栈的判空
	template <typename T>
	bool MyStack<T>::stackEmpty()
	{
		if (0==m_iTop)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	//栈的判满
	template <typename T>
	bool MyStack<T>::stackFull()
	{
		if ( m_iTop == m_iSize)//>=
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	//清空栈
	template <typename T>
	void MyStack<T>::clearStack()
	{
		m_iTop = 0;//原栈中所有值无效
	}
	//栈的长度
	template <typename T>
	int MyStack<T>::stackLength()
	{
		return m_iTop;
	}
	//元素入栈
	template <typename T>
	bool MyStack<T>::push(T elem)//放入栈顶
	{
		if (stackFull())
		{
			return false;
		}
		m_pBuffer[m_iTop] = elem;
		m_iTop++;
		return true;
	}
	//元素出栈
	template <typename T>
	bool MyStack<T>::pop(T &elem)
	{
		if (stackEmpty())
		{
			return false;
		}
		m_iTop--;//因为入栈时做了++，使栈顶指向下一个空位置
		elem = m_pBuffer[m_iTop];
		return true;
	}
	//遍历栈中元素
	template <typename T>
	void MyStack<T>::stackTraverse(bool isFromButtom)
	{
		if (isFromButtom)
		{
			for (int i = 0; i < m_iTop; i++)
			{
				cout << m_pBuffer[i];
			}
		}
		else
		{
			for (int i = m_iTop - 1; i >= 0; i--)
			{
				cout << m_pBuffer[i];
			}
		}
		cout<<endl;
	}
	```

### 栈的应用（进制转换）

	```c++
	#include "MyStack.h"
	#include <iostream>
	#include <stdlib.h>
	using namespace std;
	/*
	栈应用1，进制转换
	短除法。不停除以进制数。保留余数。然后商继续除以进制保留余数。直到商为0
	栈的应用：将每次的余数  入栈。然后从栈顶开始打印。
	*/
	#define BINARY 2
	#define OCTONARY 8
	#define HEXADECIMAL 16
	int main(void)
	{
		char num[] = "0123456789ABCDEF";
		MyStack<int> *pStack = new MyStack<int>(30);
		int N = 2017;
		int mod = 0;
		while (N !=0)
		{
			mod = N % HEXADECIMAL;
			pStack->push(mod);
			N = N / HEXADECIMAL;
		}
		//pStack->stackTraverse(false);
		int elem = 0;
		while (!pStack->stackEmpty())
		{
			pStack->pop(elem);
			cout<<num[elem];
		}
		cout<<endl;
		delete pStack;
		pStack = NULL;
		system("pause");
		return 0;
	}
	```

### 栈的应用（括号匹配）

	```c++
	#include "MyStack.h"
	#include <iostream>
	#include <stdlib.h>
	using namespace std;
	/*
	栈应用2，括号匹配
	描述：输入任意一组括号，判段括号是否匹配。
	例如：[()]
	原理：从前往后扫描。左括号入栈，当前需要匹配括号栈入栈相应的右括号，当遇到当前需要匹配括号栈入栈栈顶右括号时左圆括号出栈。如果出现不匹配的右括号或者栈中还有东西则不是全部匹配，如果字符串扫描完毕时栈为空则全部匹配。
	*/
	int main(void)
	{
		//存字符栈
		MyStack<char> *pStack = new MyStack<char>(30);
		//需要的括号
		MyStack<char> *pNeedStack = new MyStack<char>(30);
		char str[]="([a(a)][a]";
		//当前需要匹配的字符
		char currentNeed=0;
		 for (int i=0;i<strlen(str);i++)
		 {
			if (str[i]!=currentNeed)
			{
				switch(str[i])
				{
					case '[':
						pStack->push(str[i]);
						if(currentNeed!=0){
							pNeedStack->push(currentNeed);
						}
						currentNeed=']';
						break;
					case '(':
						pStack->push(str[i]);
						if(currentNeed!=0){
							pNeedStack->push(currentNeed);
						}
						currentNeed=')';
						break;
					case '{':
						pStack->push(str[i]);
						if(currentNeed!=0){
							pNeedStack->push(currentNeed);
						}
						currentNeed='}';
						break;
					case ']':
					case '}':
					case ')':
						cout<<"括号不匹配"<<endl;
						delete pStack;
						pStack = NULL;
						delete pNeedStack;
						pNeedStack = NULL;
						system("pause");
						return 0;
				}
			}else{
				char elem;
				pStack->pop(elem);
				if(!(pNeedStack->pop(currentNeed))){
					currentNeed=0;
				}
			} 
		 }
	if (pStack->stackEmpty())
	{
		cout<<"括号匹配"<<endl;
	} 
	else
	{
		cout<<"括号不匹配"<<endl;
	}
		
		cout<<endl;
		delete pStack;
		pStack = NULL;
		delete pNeedStack;
		pNeedStack = NULL;
		system("pause");
		return 0;
	}
	```