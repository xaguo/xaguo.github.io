---
title: 数据结构之线性表
date: 2017-09-07 15:48:23
tags: [数据结构,C++]
---

线性表是 n 个数据元素的有限序列。

线性表分为顺序表（数组）和链表（静态链表、单链表、循环链表、双向链表）。
<!-- more -->

数组带下标，访问速度快，搜索能力强。

顺序表的优缺点：

优点：遍历和寻址效率高。缺点：插入、删除元素时，效率低。


## 顺序表编码实现(int)

List.h

	```c++
	#pragma once
	#include <stdio.h>
	//顺序表 int 
	class List
	{
	public:
		List(int size);//创建线性表
		~List(void);//销毁线性表
		void ClearList();//清空线性表
		bool ListEmpty();//判断线性表是否为空
		int ListLength();//返回线性表的长度
		bool GetElem(int i,int *e);//获取指定位置的元素
		int LocateElem(int *e);//定位元素
		bool PriorElem(int *currentElem,int *preElem);//获取指定元素的前驱
		bool NextElem(int *currentElem,int *nextElem);//获取指定元素的的后继
		bool ListInsert(int i,int *e);//插入元素
		bool ListDelete(int i,int *e);//删除元素
		void ListTraverse();//遍历线性表
	private:
		int *m_pList;//存储线性表的数组
		int m_iSize;//存储线性表的数组的大小
		int m_iLenght;//数组中数据成员的个数
	};
	```

List.cpp

	```c++
	#include "List.h"
	#include <iostream>
	using namespace std;
	List::List(int size)
	{
		m_iSize=size;
		m_pList=new int[m_iSize];
		m_iLenght=0;
	}
	List::~List(void)
	{
		delete []m_pList;
		m_pList=NULL;
	}
	//清空线性表
	void List::ClearList()
	{
		m_iLenght=0;
	}
	//判断线性表是否为空
	bool List::ListEmpty()
	{
		return m_iLenght==0?true:false;
	}
	//返回线性表的长度
	int List::ListLength()
	{
		return m_iLenght;
	}
	//获取指定位置的元素
	bool List::GetElem(int i,int *e)
	{
		if (i<0||i>m_iLenght-1)
		{
			return false;
		}
		*e=m_pList[i];
		return true;
	}
	//定位元素
	int List::LocateElem(int *e)
	{
		for (int i=0;i<m_iLenght;i++)
		{
			if (m_pList[i]==*e)
			{
				return i;
			}
		}
		return -1;
	}
	//获取指定元素的前驱
	bool List::PriorElem(int *currentElem,int *preElem)
	{
		int temp = LocateElem(currentElem);
		if (temp==-1)
		{
			return false;
		}else 
		{
			if (temp==0)
			{
				return false;
			}else
			{
				*preElem=m_pList[temp-1];
				return true;
			}
		}
	}
	//获取指定元素的后继
	bool List::NextElem(int *currentElem,int *nextElem)
	{
		int temp = LocateElem(currentElem);
		if (temp==-1)
		{
			return false;
		}else 
		{
			if (temp==m_iLenght-1)
			{
				return false;
			}else
			{
				*nextElem=m_pList[temp+1];
				return true;
			}
		}
	}
	//遍历线性表
	void List::ListTraverse()
	{
		for (int i=0;i<m_iLenght;i++)
		{
			cout<<m_pList[i]<<endl;
		}
	}
	//插入元素
	bool List::ListInsert(int i,int *e)
	{
		if(i<0||i>m_iLenght||m_iLenght>=m_iSize)
		{
			return false;
		}
		for (int k=m_iLenght-1;k>=i;k--)
		{
			m_pList[k+1]=m_pList[k];
		}
		m_pList[i]=*e;
		m_iLenght++;
		return true;
	}
	//删除元素
	bool List::ListDelete(int i,int *e)
	{
		if(i<0||i>=m_iLenght||m_iLenght>=m_iSize)
		{
			return false;
		}
		*e=m_pList[i];
		for (int k=i+1;k<m_iLenght;k++)
		{
			m_pList[k-1]=m_pList[k];
		}
		m_iLenght--;
		return true;
	}
	```

demo.cpp

	```c++
	#include <stdlib.h>
	#include "List.h"
	#include <iostream>
	using namespace std;
	int main(void){
		int e1=3;
		int e2=4;
		int e3=5;
		int e4=6;
		int e5=7;
		int e6=8;
		List *list1=new List(10);
		cout<<"leagth:"<<list1->ListLength()<<endl;
		list1->ListInsert(0,&e1);
		list1->ListInsert(1,&e2);
		list1->ListInsert(2,&e3);
		list1->ListInsert(3,&e4);
		list1->ListInsert(4,&e5);
		list1->ListInsert(2,&e6);
		list1->ListTraverse();
		cout<<"leagth:"<<list1->ListLength()<<endl;
		int temp;
		list1->ListDelete(0,&temp);
		cout<<"#"<<temp<<endl;
		cout<<endl;
		list1->ListTraverse();
		if(!(list1->ListEmpty())){
			cout<<"not Enpty"<<endl;
		}
		list1->ClearList();
		if((list1->ListEmpty())){
			cout<<"Enpty"<<endl;
		}
		list1->ListTraverse();
		list1->ListInsert(0,&e1);
		list1->ListInsert(1,&e2);
		list1->ListInsert(2,&e3);
		list1->ListInsert(3,&e4);
		list1->ListInsert(4,&e5);
		list1->ListInsert(5,&e6);
		list1->ListTraverse();
		list1->GetElem(1,&temp);
		cout<<"1:"<<temp<<endl;
		temp=8;
		cout<<temp<<" local "<<list1->LocateElem(&temp)<<endl;
		list1->PriorElem(&e3,&temp);
		cout<<e3<<"pre:"<<temp<<endl;
		list1->NextElem(&e3,&temp);
		cout<<e3<<"next:"<<temp<<endl;
		delete list1;
		system("pause");
		return 0;
	}
	```

## 顺序表编码实现(Coordiante)

Coordinate.h

	```c++
	#pragma once
	#include <ostream>
	using namespace std;
	class Coordinate
	{
		friend ostream &operator<<(ostream &out,Coordinate &coor);
	public:
		bool operator==(Coordinate &coor);//重载运算符 ==
		Coordinate(int x=0,int y=0);//加初始值，变成默认的构造函数
		void printCoordinate();
	private:
		int m_iX;
		int m_iY;
	};
	```

Coordinate.cpp

	```c++
	#include "Coordinate.h"
	#include <iostream>
	#include <ostream>
	using namespace std;
	Coordinate::Coordinate(int x, int y)
	{
		m_iX = x;
		m_iY = y;
	}
	void Coordinate::printCoordinate()
	{
		cout << "(" << m_iX << "," << m_iY << ")" << endl;
	}
	ostream &operator<<(ostream &out,Coordinate &coor)
	{
		out<<"("<<coor.m_iX<<","<<coor.m_iY<<")"<<endl;
		return out;
	}
	//重载运算符 ==
	bool Coordinate::operator==(Coordinate &coor)
	{
		if(this->m_iX==coor.m_iX&&this->m_iY==coor.m_iY)
		{
			return true;
		}else
		{
			return false;
		}
	}
	```

list.h

	```c++
	#pragma once
	#include <stdio.h>
	#include "Coordinate.h"
	//顺序表 Coordinate 
	class List
	{
	public:
		List(int size);//创建线性表
		~List(void);//销毁线性表
		void ClearList();//清空线性表
		bool ListEmpty();//判断线性表是否为空
		int ListLength();//返回线性表的长度
		bool GetElem(int i,Coordinate *e);//获取指定位置的元素
		int LocateElem(Coordinate *e);//定位元素
		bool PriorElem(Coordinate *currentElem,Coordinate *preElem);//获取指定元素的前驱
		bool NextElem(Coordinate *currentElem,Coordinate *nextElem);//获取指定元素的的后继
		bool ListInsert(int i,Coordinate *e);//插入元素
		bool ListDelete(int i,Coordinate *e);//删除元素
		void ListTraverse();//遍历线性表
	private:
		Coordinate *m_pList;//存储线性表的数组
		int m_iSize;//存储线性表的数组的大小
		int m_iLenght;//数组中数据成员的个数
	};
	```

list.cpp

	```c++
	#include "List.h"
	#include <iostream>
	using namespace std;
	List::List(int size)
	{
		m_iSize=size;
		m_pList=new Coordinate[m_iSize];
		m_iLenght=0;
	}
	List::~List(void)
	{
		delete []m_pList;
		m_pList=NULL;
	}
	//清空线性表
	void List::ClearList()
	{
		m_iLenght=0;
	}
	//判断线性表是否为空
	bool List::ListEmpty()
	{
		return m_iLenght==0?true:false;
	}
	//返回线性表的长度
	int List::ListLength()
	{
		return m_iLenght;
	}
	//获取指定位置的元素
	bool List::GetElem(int i,Coordinate *e)
	{
		if (i<0||i>m_iLenght-1)
		{
			return false;
		}
		*e=m_pList[i];
		return true;
	}
	//定位元素
	int List::LocateElem(Coordinate *e)
	{
		for (int i=0;i<m_iLenght;i++)
		{
			if (m_pList[i]==*e)
			{
				return i;
			}
		}
		return -1;
	}
	//获取指定元素的前驱
	bool List::PriorElem(Coordinate *currentElem,Coordinate *preElem)
	{
		int temp = LocateElem(currentElem);
		if (temp==-1)
		{
			return false;
		}else 
		{
			if (temp==0)
			{
				return false;
			}else
			{
				*preElem=m_pList[temp-1];
				return true;
			}
		}
	}
	//获取指定元素的后继
	bool List::NextElem(Coordinate *currentElem,Coordinate *nextElem)
	{
		int temp = LocateElem(currentElem);
		if (temp==-1)
		{
			return false;
		}else 
		{
			if (temp==m_iLenght-1)
			{
				return false;
			}else
			{
				*nextElem=m_pList[temp+1];
				return true;
			}
		}
	}
	//遍历线性表
	void List::ListTraverse()
	{
		for (int i=0;i<m_iLenght;i++)
		{
			cout<<m_pList[i]<<endl;
			//m_pList[i].printCoordinate();
		}
	}
	//插入元素
	bool List::ListInsert(int i,Coordinate *e)
	{
		if(i<0||i>m_iLenght||m_iLenght>=m_iSize)
		{
			return false;
		}
		for (int k=m_iLenght-1;k>=i;k--)
		{
			m_pList[k+1]=m_pList[k];
		}
		m_pList[i]=*e;
		m_iLenght++;
		return true;
	}
	//删除元素
	bool List::ListDelete(int i,Coordinate *e)
	{
		if(i<0||i>=m_iLenght||m_iLenght>=m_iSize)
		{
			return false;
		}
		*e=m_pList[i];
		for (int k=i+1;k<m_iLenght;k++)
		{
			m_pList[k-1]=m_pList[k];
		}
		m_iLenght--;
		return true;
	}
	```

测试 demo.cpp

	```c++
	#include <stdlib.h>
	#include "List.h"
	#include <iostream>
	#include "Coordinate.h"
	using namespace std;
	int main(void){
		Coordinate e1(3,4);
		Coordinate e2(4,5);
		Coordinate e3(5,6);
		Coordinate e4(6,7);
		Coordinate e5(7,8);
		Coordinate e6(8,9);
		List *list1=new List(10);
		cout<<"leagth:"<<list1->ListLength()<<endl;
		list1->ListInsert(0,&e1);
		list1->ListInsert(1,&e2);
		list1->ListInsert(2,&e3);
		list1->ListInsert(3,&e4);
		list1->ListInsert(4,&e5);
		list1->ListInsert(2,&e6);
		list1->ListTraverse();
		cout<<"leagth:"<<list1->ListLength()<<endl;
		Coordinate temp(0,0);
		list1->ListDelete(0,&temp);
		cout<<"#"<<temp<<endl;
		cout<<endl;
		list1->ListTraverse();
		if(!(list1->ListEmpty())){
			cout<<"not Enpty"<<endl;
		}
		list1->ClearList();
		if((list1->ListEmpty())){
			cout<<"Enpty"<<endl;
		}
		list1->ListTraverse();
		list1->ListInsert(0,&e1);
		list1->ListInsert(1,&e2);
		list1->ListInsert(2,&e3);
		list1->ListInsert(3,&e4);
		list1->ListInsert(4,&e5);
		list1->ListInsert(5,&e6);
		list1->ListTraverse();
		list1->GetElem(1,&temp);
		cout<<"1:"<<temp<<endl;
		Coordinate temp1(4,5);
		cout<<temp1<<" local "<<list1->LocateElem(&temp1)<<endl;
		list1->PriorElem(&e3,&temp1);
		cout<<e3<<"pre:"<<temp1<<endl;
		list1->NextElem(&e3,&temp1);
		cout<<e3<<"next:"<<temp1<<endl;
		delete list1;
		system("pause");
		return 0;
	}
	```

