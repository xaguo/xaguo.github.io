---
title: 数据结构之队列
date: 2017-09-05 15:21:37
tags: [数据结构,C++]
---

数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。

队列：先入先出（FIFO，first in first out),分为普通队列和环形队列。
<!-- more -->

##环形队列编码实现

//环形队列编码实现

	```c++
	#include<iostream>
	using namespace std;
	class MyQueue
	{
	//建立一个环形队列的对象的方法
	public:
		MyQueue(int queueCapacity);//创建队列
		virtual ~MyQueue();//销毁队列
		void ClearQueue();//清空队列
		bool QueueEmpty()const;//判空队列检测
		bool QueueFull()const;//判满队列检测
		int QueueLength();//队列的长度
		bool EnQueue(int element);//新元素进队
		bool DeQueue(int &element);//首元素出队
		void QueueTraverse();///*遍历队列
	private:
		int *m_pqueue;//队列数组指针
		int m_iQueueLen;//队列长度
		int m_iQueueCapacity;//队列数组容量*/
		int m_iHead;//队列头下标
		int m_iTail;//队列尾下标
	};
	//创建队列
	MyQueue::MyQueue(int queueCapacity)
	{
		m_iQueueCapacity=queueCapacity;
		ClearQueue();
		m_pqueue=new int[m_iQueueCapacity];
	}
	//销毁队列
	MyQueue::~MyQueue()
	{
		delete []m_pqueue;
		m_pqueue=NULL;
	}
	//清空队列
	void MyQueue::ClearQueue()
	{
		m_iHead=0;
		m_iTail=0;
		m_iQueueLen=0;
	}
	//判空队列检测
	bool MyQueue::QueueEmpty()const
	{
		return m_iQueueLen==0?true:false;
	}
	//判满队列检测
	bool MyQueue::QueueFull()const
	{
		return m_iQueueLen==m_iQueueCapacity?true:false;
	}
	//队列的长度
	int MyQueue::QueueLength()
	{
		return m_iQueueLen;
	}
	//新元素进队
	bool MyQueue::EnQueue(int element)
	{
		if(QueueFull())
		{
			return false;
		}
		else
		{
			m_pqueue[m_iTail ]=element;
			m_iTail++;
			m_iTail=m_iTail%m_iQueueCapacity;
			m_iQueueLen++;
			return true;
		}
	}
	//首元素出队
	bool MyQueue::DeQueue(int &element)
	{
		if(QueueEmpty())
		{
			return false;
		}
		else
		{
			element=m_pqueue[m_iHead];
			m_iHead++;
			m_iHead=m_iHead%m_iQueueCapacity;
			m_iQueueLen--;
			return true;
		}
	}
	//遍历队列
	void MyQueue::QueueTraverse()
	{	cout<<endl;
		for(int i=m_iHead;i<m_iQueueLen+m_iHead;i++)
		{
			cout<<m_pqueue[i%m_iQueueCapacity]<<endl;
		}
		cout<<endl;
	}
	//测试
	int main(void)
	{
		MyQueue *p=new MyQueue(4);
		//插入元素
		p->EnQueue(12);
		p->EnQueue(22);
		p->EnQueue(25);
		p->EnQueue(27);
		//p->EnQueue(10);
		//遍历
		p->QueueTraverse();
		cout<<endl;
		//队列长度
		cout<<p->QueueLength()<<endl;
		//队列判满
		cout<<p->QueueFull()<<endl;
		//队列判空
		cout<<p->QueueEmpty()<<endl;
		cout<<endl;
		//首元素出队
		int e=0;
		p->DeQueue(e);
		cout<<e<<endl;
		cout<<endl;
		//首元素出队
		p->DeQueue(e);
		cout<<e<<endl;
		cout<<endl;
		//遍历
		p->QueueTraverse();
		//清空队列
		p->ClearQueue();
		//遍历
		p->QueueTraverse();
		//插入元素
		p->EnQueue(11);
		p->EnQueue(21);
		//遍历
		p->QueueTraverse();
		delete p;
		p=NULL;
		system("pause");
		return 0;
	}
	```

元素用 Customer 对象

	```c++
	//Customer.h
	#pragma once
	#include <string>
	using namespace std;
	class Customer
	{
	public:
		Customer(string name="",int age=0);
		~Customer(void);
		void printInfo()const;
	private:  
		string m_strName;
		int m_iAge;
	};
	```

Customer.cpp

	```c++
	#include "Customer.h"
	#include <iostream>
	using namespace std;
	Customer::Customer(string name,int age)
	{
		m_strName=name;
		m_iAge=age;
	}
	Customer::~Customer(void)
	{
	}
	void Customer::printInfo()const
	{
		cout<<"姓名："<<m_strName<<endl;
		cout<<"年龄："<<m_iAge<<endl;
		cout<<endl;
	}
	```

MyQueue.h

	```c++
	#pragma once
	class MyQueue
	{
	public:
		//建立一个环形队列的对象的方法
	public:
		MyQueue(int queueCapacity);//创建队列
		virtual ~MyQueue();//销毁队列
		void ClearQueue();//清空队列
		bool QueueEmpty()const;//判空队列检测
		bool QueueFull()const;//判满队列检测
		int QueueLength();//队列的长度
		bool EnQueue(int element);//新元素进队
		bool DeQueue(int &element);//首元素出队
		void QueueTraverse();///*遍历队列
	private:
		int *m_pqueue;//队列数组指针
		int m_iQueueLen;//队列长度
		int m_iQueueCapacity;//队列数组容量*/
		int m_iHead;//队列头下标
		int m_iTail;//队列尾下标
	};
	```

MyQueue.cpp

	```c++
	//环形队列编码实现
	#include "MyQueue.h"
	#include<iostream>
	using namespace std;
	//创建队列
	MyQueue::MyQueue(int queueCapacity)
	{
		m_iQueueCapacity=queueCapacity;
		ClearQueue();
		m_pqueue=new Customer[m_iQueueCapacity];
	}
	//销毁队列
	MyQueue::~MyQueue()
	{
		delete []m_pqueue;
		m_pqueue=NULL;
	}
	//清空队列
	void MyQueue::ClearQueue()
	{
		m_iHead=0;
		m_iTail=0;
		m_iQueueLen=0;
	}
	//判空队列检测
	bool MyQueue::QueueEmpty()const
	{
		return m_iQueueLen==0?true:false;
	}
	//判满队列检测
	bool MyQueue::QueueFull()const
	{
		return m_iQueueLen==m_iQueueCapacity?true:false;
	}
	//队列的长度
	int MyQueue::QueueLength()
	{
		return m_iQueueLen;
	}
	//新元素进队
	bool MyQueue::EnQueue(Customer element)
	{
		if(QueueFull())
		{
			return false;
		}
		else
		{
			m_pqueue[m_iTail ]=element;
			m_iTail++;
			m_iTail=m_iTail%m_iQueueCapacity;
			m_iQueueLen++;
			return true;
		}
	}
	//首元素出队
	bool MyQueue::DeQueue(Customer &element)
	{
		if(QueueEmpty())
		{
			return false;
		}
		else
		{
			element=m_pqueue[m_iHead];
			m_iHead++;
			m_iHead=m_iHead%m_iQueueCapacity;
			m_iQueueLen--;
			return true;
		}
	}
	//遍历队列
	void MyQueue::QueueTraverse()
	{	
		for(int i=m_iHead;i<m_iQueueLen+m_iHead;i++)
		{
			cout<<"前面还有："<<(i-m_iHead)<<"人"<<endl;
			m_pqueue[i%m_iQueueCapacity].printInfo();
		}
		cout<<endl;
	}
	```

测试 demo.cpp

	```c++
	#include<iostream>
	#include "Customer.h"
	#include <stdlib.h>
	#include "MyQueue.h"
	using namespace std;
	//测试
	int main(void)
	{
		MyQueue *p=new MyQueue(4);
		Customer c1("XA",18);
		Customer c2("XB",19);
		Customer c3("XC",20);
		Customer c4("XD",21);
		Customer c5("XE",22);
		//插入元素
		p->EnQueue(c1);
		p->EnQueue(c2);
		p->EnQueue(c3);
		p->EnQueue(c4);
		//p->EnQueue(c5);
		//遍历
		p->QueueTraverse();
		cout<<endl;
		//队列长度
		cout<<p->QueueLength()<<endl;
		//队列判满
		cout<<p->QueueFull()<<endl;
		//队列判空
		cout<<p->QueueEmpty()<<endl;
		cout<<endl;
		//首元素出队
		Customer e;
		p->DeQueue(e);
		e.printInfo();
		//首元素出队
		p->DeQueue(e);
		e.printInfo();
		//遍历
		p->QueueTraverse();
		//清空队列
		p->ClearQueue();
		//遍历
		p->QueueTraverse();
		//插入元素
		p->EnQueue(c4);
		p->EnQueue(c5);
		//遍历
		p->QueueTraverse();
		delete p;
		p=NULL;
		system("pause");
		return 0;
	}
	```



