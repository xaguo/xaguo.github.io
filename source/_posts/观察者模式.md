---
title: 观察者模式
date: 2017-09-01 16:54:00
tags: [设计模式,Java]
---

定义对象间的一种一对多的依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。<!-- more -->

- 实现步骤：
1. 目标对象的定义
2. 具体的目标对象的定义
3. 观测者模式的接口定义
4. 观察者模式的具体实现
- 目标与观察者之间的关系
一对一 多对一

- 命名建议
目标接口的定义，建议在名称后面跟 Subject

观察者接口的定义，建议在名称后面跟 Observer

观察者接口的更新方法，建议名称为 update

- 发出通知的时机
在完成了状态维护后触发。

- 实现方式
推模型：目标对象向观察者推送目标的详细信息。推送的信息通常是目标对象的全部或部分数据。

拉模型：目标对象在通知观测者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。一般这种模型的实现中，会把目标自身通过 update 方法传递给观察者。

比较：

推模型是假定目标对象知道观察者需要的数据。推模型会使对象难以复用。

拉模型目标对象不知道观察者具体需要什么数据，因此把自身传给观察者，由观察者来取值。拉模型下，update 方法的参数是目标对象本身，基本上可以适应各种情况的需要。

## 拉模型代码 Demo ##

	```java
	package weatherobserver.xa;
	import java.util.ArrayList;
	import java.util.List;
	/**
	 * 目标对象，它知道它的观察者，并提供注册（添加）和删除观察者的接口
	 * 
	 * @author XA
	 */
	public class WeatherSubject {
		// 用来保存注册的观察者对象
		private List<WeatherObserver> observers = new ArrayList<WeatherObserver>();
		// attach detach notifyObservers
		/**
		 * 把订阅天气的人添加到订阅者列表中
		 * 
		 * @param observer
		 */
		public void attach(WeatherObserver observer) {
			observers.add(observer);
		}
		/**
		 * 删除观察者集合中的指定订阅天气的人
		 * 
		 * @param observer
		 */
		public void detach(WeatherObserver observer) {
			observers.remove(observer);
		}
		/**
		 * 通知所有注册的已经订阅天气的人
		 */
		protected void notifyObservers() {
			for(WeatherObserver observer:observers){
				observer.update(this);
			}
		}
	}
	```

-

	```java
	package weatherobserver.xa;
	/**
	 * 具体的目标对象，负责把有关的状态存入到相应的观察者对象中
	 * 
	 * @author XA
	 */
	public class WeatherSpecificSubject extends WeatherSubject {
		// 天气的内容信息
		private String weatherContent;
		public String getweatherContent() {
			return weatherContent;
		}
		public void setweatherContent(String weatherContent) {
			this.weatherContent = weatherContent;
			//内容有了，说明天气更新了，通知所有订阅天气的人
			this.notifyObservers();
		}
	}
	```

-

	```java
	package weatherobserver.xa;
	/**
	 * 这是一个观察者接口，定义一个更新的接口给那些在目标发生改变的时候被通知的对象
	 * @author XA
	 */
	public interface WeatherObserver {
		/**
		 * 更新的接口
		 * @param subject 传入的目标对象，方便获取相应的目标对象的状态
		 */
		public void update(WeatherSubject subject);
	}
	```

-

	```java
	package weatherobserver.xa;
	/**
	 * 这是具体的观察者对象，实现更新的方法，使自身的状态和目标的状态保持一致
	 * 
	 * @author XA
	 */
	public class WeatherSpecificObserver implements WeatherObserver {
		// 观察者的名字
		private String observerName;
		//天气内容的情况，这个消息从目标处获取
		private String weatherContent;
		//提醒的内容
		private String remindContent;
		public String getObserverName() {
			return observerName;
		}
		public void setObserverName(String observerName) {
			this.observerName = observerName;
		}
		public String getWeatherContent() {
			return weatherContent;
		}
		public void setWeatherContent(String weatherContent) {
			this.weatherContent = weatherContent;
		}
		public String getRemindContent() {
			return remindContent;
		}
		public void setRemindContent(String remindContent) {
			this.remindContent = remindContent;
		}
		/**
		 * 获取目标类的对象，同步到观察者中
		 */
		@Override
		public void update(WeatherSubject weatherSubject) {
			weatherContent = ((WeatherSpecificSubject) weatherSubject).getweatherContent();
			System.out.println(observerName+" 收到了 "+weatherContent+","+remindContent);
		}
	}
	```

-

	```java
	package weatherobserver.xa;
	/**
	 * 测试类
	 * @author XA
	 *
	 */
	public class Client {
		public static void main(String[] args) {
			//1. 创建目标
			WeatherSpecificSubject wss=new WeatherSpecificSubject();
			//2.创建观察者
			WeatherSpecificObserver observerGirl=new WeatherSpecificObserver();
			observerGirl.setObserverName("XB");
			observerGirl.setRemindContent("街心公园");
			
			WeatherSpecificObserver observerMum =new WeatherSpecificObserver();
			observerMum.setObserverName("Mum");
			observerMum.setRemindContent("适合购物");
			
			//3.注册观察者
			wss.attach(observerGirl);
			wss.attach(observerMum);
			
			//4.目标发布天气
			wss.setweatherContent("明天天气晴朗，蓝天白云~");
		}
	}
	```

## Java 提供的观察者实现 ##

1. 不需要定义观察者和目标接口
2. 具体目标实现里面不需要再维护观察者的注册信息，在 Java 中 Observerable 类里已经实现好了。
3. 触发通知的方式有一点改变，要先调用 setChanged 方法，这个 Java 为了帮助实现更精确的触发控制而提供的功能。
4. 具体的观察者实现里面，update 方法其实同时支持推模型和拉模型，这个是 Java 在定义的时候，就已经考虑了的。

举例

	```java
	import java.util.Observable;
	/**
	 * 天气具体的目标实现类
	 * 
	 * @author XA
	 */
	public class SpecificWeatherSubject extends Observable {
		private String WeatherContent;
		public String getWeatherContent() {
			return WeatherContent;
		}
		public void setWeatherContent(String weatherContent) {
			WeatherContent = weatherContent;
			// 天气有了，就要通知所有的观察者
			// 用 Java 中的 Observer 模式的时候，注意在通知之前，下面这句话不可少。
			this.setChanged();
			// 然后主动通知，这里先用推模型
			this.notifyObservers(WeatherContent);
			// 如果只拉方式，就调用
			// this.notifyObservers();
		}
	}
	```

-

	```java
	import java.util.Observable;
	import java.util.Observer;
	/**
	 * 具体的观察者对象
	 * 
	 * @author XA
	 *
	 */
	public class SpecificWeatherObserver implements Observer {
		// 定义一个观察者的名称对象
		private String observerName;
		@Override
		public void update(Observable o, Object arg) {
			// 第一种是推的方式
			System.out.println(observerName + "收到了消息，目标推送的消息是：" + arg);
			// 第二种是拉的方式
			System.out.println(observerName + "收到了消息，主动到目标对象去拉，拉的内容是："
					+ ((SpecificWeatherSubject) o).getWeatherContent());
		}
		public String getObserverName() {
			return observerName;
		}
		public void setObserverName(String observerName) {
			this.observerName = observerName;
		}
	}
	```

-

	```java
	/**
	 * 测试类
	 * 
	 * @author XA
	 *
	 */
	public class Client {
		public static void main(String[] args) {
			// 创建天气作为一个目标，可以说是观察者
			SpecificWeatherSubject subject = new SpecificWeatherSubject();
			// 创建观察者1
			SpecificWeatherObserver observer1 = new SpecificWeatherObserver();
			observer1.setObserverName("XA");
			// 创建观察者2
			SpecificWeatherObserver observer2 = new SpecificWeatherObserver();
			observer2.setObserverName("XB");
			// 注册观察者
			subject.addObserver(observer1);
			subject.addObserver(observer2);
			// 目标通知天气更新情况
			subject.setWeatherContent("天气晴朗，阳关明媚~");
		}
	}
	```

## 观察者的优缺点 ##
优点：

1. 观察者模式实现了观察者和目标之间的抽象耦合。
2. 观察者模式实现了动态联动。
3. 观察者模式支持广播通信。

缺点：可能会引起无谓的操作

- 观察者模式的应用场景
触发联动（观察者模式的本质）

1. 当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化。
2. 如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变。
3. 当一个对象必须通知其他对象，但是你又希望对这个对象和他被它通知的对象是松散耦合的。

区别对待观察者的场景问题，在目标对观察者进行广播的时候进行判断。
