---
title: 数据结构之图
date: 2017-09-10 21:55:09
tags: [数据结构,C++]
---
图的表示、图的遍历、最小生成树、图的应用（路径规划、工程规划、战略规划）。
<!-- more -->

## 图的基本概念

图是由节点和节点之间连线的集合。分为：有向图、无向图。

<center>
	<img src="./a.png" width="300px"></img>
</center>

入度：有向图指进来的数量。出度：有向图指出去的数量。(V1)入度 1，出度 2。

<center>
	<img src="./b.png" width="250px"><img src="./c.png" width="250px">
</center>

连通图：对于图中的所有顶点，都有直接或者间接通往其他顶点的连线。

<center>
	<img src="./d.png" width="300px"></img>
</center>

完全图：边数=n(n-1)/2【n 为顶点数】

<center>
	<img src="./e.png" width="300px"></img>
</center>

生成树：边数=n-1 【n 为顶点数】

<center>
	<img src="./f.png" width="300px"></img>
</center>

## 图的存储结构

邻接矩阵（用数组表达）

邻接表（用链表表达有向图）

十字链表（用链表表达有向图）

邻接多重表（用链表表达无向图）

- 邻接矩阵

<center>
	<img src="./g.png" width="200px"><img src="./h.png" width="200px">
</center>
<center>
	<img src="./i.png" width="400px">
</center>
<center>
	<img src="./j.png" width="400px">
</center>
<center>
	<img src="./k.png" width="400px">
</center>
<center>
	<img src="./l.png" width="400px">
</center>

- 邻接表

<center>
	<img src="./m.png" width="400px">
</center>

<center>
	<img src="./n.png" width="400px">
</center>

- 十字链表

<center>
	<img src="./o.png" width="400px">
</center>
<center>
	<img src="./p.png" width="400px">
</center>
<center>
	<img src="./q.png" width="400px">
</center>

## 图的遍历

- 深度优先搜索

前序遍历

<center>
	<img src="./r.png" width="400px">
</center>

- 广度优先搜索

按层搜索

<center>
	<img src="./t.png" width="400px">
</center>

## 邻接矩阵的编码实现

Node.h

	```c++
	#pragma once
	class Node
	{
	public:
		Node(char data=0);//构造函数，data 是数据值
		char m_cData;//数据值
		bool m_bIsVisited;//当前节点是否被访问过
	};
	```

Node.cpp

	```c++
	#include "Node.h"
	Node::Node(char data)
	{
		m_cData=data;
		m_bIsVisited=false;
	}
	```

Map.h

	```c++
	#pragma once
	#include <stdio.h>
	#include <vector>
	using namespace std;
	#include "Node.h"
	//邻接矩阵
	class Map
	{
	public:
		Map(int capacity);//构造函数
		~Map();//析构函数
		bool addNode(Node *pNode);//向图中加入顶点（节点）
		void resetNode();//重置顶点
		bool setValueToMatrixForDirectedGraph(int row,int col,int val = 1);//为有向图设置邻接矩阵
		bool setValueToMatrixForUndirectedGraph(int row,int col,int val=1);//为无向图设置邻接矩阵
		void printMatrix();//打印邻接矩阵
		void depthFirstTraverse(int nodeIndex);//深度优先遍历
		void breadthFirstTraverse(int nodeIndex);//广度优先遍历
	private:
		bool getValueFromMatrix(int row,int col,int &val);//从矩阵中获取权值
		void breadthFirstTraverseImpl(vector<int> preVec);//广度优先遍历实现函数
	private:
		int m_iCapacity;//图中最多可以容纳的顶点数
		int m_iNodeCount;//已经添加的顶点（节点）个数
		Node *m_pNodeArray;//用来存放顶点的数组
		int *m_pMatrix;//用来存放邻接矩阵
	};
	```
	
Map.cpp

	```c++
	#include "Map.h"
	#include<iostream>
	#include <vector>
	using namespace std;
	//构造函数
	Map::Map(int capacity)
	{
		m_iCapacity=capacity;
		m_iNodeCount=0;
		m_pNodeArray=new Node[m_iCapacity];
		m_pMatrix=new int[m_iCapacity*m_iCapacity];
		//临街矩阵初始化
		memset(m_pMatrix,0,m_iCapacity*m_iCapacity*sizeof(int));
	}
	//析构函数
	Map::~Map()
	{
		delete []m_pNodeArray;
		m_pNodeArray=NULL;
		delete []m_pMatrix;
		m_pMatrix=NULL;
	}
	//向图中加入顶点（节点）
	bool Map::addNode(Node *pNode)
	{
		if (pNode==NULL)
		{
			return false;
		}
		m_pNodeArray[m_iNodeCount].m_cData=pNode->m_cData;
		m_iNodeCount++;
		return true;
	}
	//重置顶点
	void Map::resetNode()
	{
		for (int i=0;i<m_iNodeCount;i++)
		{
			m_pNodeArray[i].m_bIsVisited=false;
		}
	}
	//为有向图设置邻接矩阵
	bool Map::setValueToMatrixForDirectedGraph(int row,int col,int val)
	{
		if(row<0&&row>=m_iCapacity)
		{
			return false;
		}
		if(col<0&&col>=m_iCapacity)
		{
			return false;
		}
		m_pMatrix[row*m_iCapacity+col]=val;
		return true;
	}
	//为无向图设置邻接矩阵
	bool Map::setValueToMatrixForUndirectedGraph(int row,int col,int val)
	{
		if(row<0&&row>=m_iCapacity)
		{
			return false;
		}
		if(col<0&&col>=m_iCapacity)
		{
			return false;
		}
		m_pMatrix[row*m_iCapacity+col]=val;
		m_pMatrix[col*m_iCapacity+row]=val;
		return true;
	}
	//从矩阵中获取权值
	bool Map::getValueFromMatrix(int row,int col,int &val)
	{
		if(row<0&&row>=m_iCapacity)
		{
			return false;
		}
		if(col<0&&col>=m_iCapacity)
		{
			return false;
		}
		val=m_pMatrix[row*m_iCapacity+col];
		return true;
	}
	//打印邻接矩阵
	void Map::printMatrix()
	{
		for (int i=0;i<m_iCapacity;i++)
		{
			for (int k=0;k<m_iCapacity;k++)
			{
				cout<<m_pMatrix[i*m_iCapacity+k]<<" ";
			}
			cout<<endl;
		}
	}
	//深度优先遍历
	void Map::depthFirstTraverse(int nodeIndex)
	{
		int value=0;
		//先访问当前节点
		cout<<m_pNodeArray[nodeIndex].m_cData<<" ";
		m_pNodeArray[nodeIndex].m_bIsVisited=true;
		//通过邻接矩阵判断是否与其他的顶点有连接
		for (int i=0;i<m_iCapacity;i++)
		{
			getValueFromMatrix(nodeIndex,i,value);
			//判断是否有弧连接其他顶点
			if(value!=0)
			{
				//在判断该点是否被访问过
				if (m_pNodeArray[i].m_bIsVisited)
				{
					continue;
				} 
				else
				{
					depthFirstTraverse(i);
				}
			}else//如果没有去向索引为 i 的顶点的弧，则循环继续
			{
				continue;
			}
		}
	}
	//广度优先遍历
	void Map::breadthFirstTraverse(int nodeIndex)
	{
		//先访问当前节点
		cout<<m_pNodeArray[nodeIndex].m_cData<<" ";
		m_pNodeArray[nodeIndex].m_bIsVisited=true;
		vector<int> curVec;//使用标准模板库中的数组
		curVec.push_back(nodeIndex);
		breadthFirstTraverseImpl(curVec);
	}
	//广度优先遍历实现函数
	void Map::breadthFirstTraverseImpl(vector<int> preVec)
	{
		int value=0;
		vector<int> curVec;
		//遍历上一层节点
		for (int j=0;j<int(preVec.size());j++)
		{
			//遍历上一层的一个节点与其他节点是否有连接
			for (int i=0;i<m_iCapacity;i++)
			{
				getValueFromMatrix(preVec[j],i,value);
				//判断是否有弧连接其他顶点
				if(value!=0)
				{
					//在判断该点是否被访问过
					if (m_pNodeArray[i].m_bIsVisited)
					{
						continue;
					} 
					else
					{
						//先访问当前节点
						cout<<m_pNodeArray[i].m_cData<<" ";
						m_pNodeArray[i].m_bIsVisited=true;
						curVec.push_back(i);
					}
				}
			}
		}
		//判断下一层是否为空层
		if (curVec.size()==0)
		{
			return;
		}else
		{
			breadthFirstTraverseImpl(curVec);
		}
	}
	```
demo.cpp

	```c++
	/*
			 A
		    /  \
		  B     D
		 / \   / \
		C   F G - H
		 \ /
		  E
	深度优先：A B C E F D F H
	广度优先：A B D C F G H E
	*/
	/*
	  A B C D E F G H
	A   1   1
	B 1   1     1
	C   1     1 1
	D 1           1 1
	E     1
	F   1 1
	G       1       1
	H       1     1
	*/
	#include<iostream>
	#include<stdlib.h>
	using namespace std;
	#include "Node.h"
	#include "Map.h"
	int main(void)
	{
		Map *pMap=new Map(8);
		Node *pNodeA=new Node('A');
		Node *pNodeB=new Node('B');
		Node *pNodeC=new Node('C');
		Node *pNodeD=new Node('D');
		Node *pNodeE=new Node('E');
		Node *pNodeF=new Node('F');
		Node *pNodeG=new Node('G');
		Node *pNodeH=new Node('H');
		pMap->addNode(pNodeA);
		pMap->addNode(pNodeB);
		pMap->addNode(pNodeC);
		pMap->addNode(pNodeD);
		pMap->addNode(pNodeE);
		pMap->addNode(pNodeF);
		pMap->addNode(pNodeG);
		pMap->addNode(pNodeH);
		pMap->setValueToMatrixForUndirectedGraph(0,1);
		pMap->setValueToMatrixForUndirectedGraph(0,3);
		pMap->setValueToMatrixForUndirectedGraph(1,2);
		pMap->setValueToMatrixForUndirectedGraph(1,5);
		pMap->setValueToMatrixForUndirectedGraph(3,6);
		pMap->setValueToMatrixForUndirectedGraph(3,7);
		pMap->setValueToMatrixForUndirectedGraph(6,7);
		pMap->setValueToMatrixForUndirectedGraph(2,4);
		pMap->setValueToMatrixForUndirectedGraph(4,5);
		pMap->printMatrix();
		cout<<endl;
		pMap->resetNode();
		pMap->depthFirstTraverse(0);
		cout<<endl;
		pMap->resetNode();
		pMap->depthFirstTraverse(1);
		cout<<endl;
		pMap->resetNode();
		pMap->breadthFirstTraverse(0);
		cout<<endl;
		pMap->resetNode();
		pMap->breadthFirstTraverse(1);
		cout<<endl;
		delete pMap;
		system("pause");
		return 0;
	}
	```

测试结果
<center>
	<img src="./result.png" width="400px">
</center>

