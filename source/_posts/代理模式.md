---
title: 代理模式
date: 2017-08-30 16:22:41
tags: [设计模式,Java]
---

代理模式是一种非常重要的设计模式，在 Java 语言中有着广泛的应用，包括Spring AOP 的核心设计思想，都和代理模式有密切关系。
<!-- more -->

- 定义
为其他对象提供一种代理，以控制对这个对象的访问。代理对象起到中介的作用，可去掉功能服务或增加额外的服务。

- 分类
1. 远程代理：为不同地理的对象提供局域网代理对象。远程监控。
2. 虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建。图片加载。
3. 保护代理：控制对一个对象访问的权限。评论权限。
4. 智能引用代理：提供对目标对象额外的服务。车票代售。

## 智能引用代理

- 静态代理：代理和被代理对象在代理之前是确定的，它们都实现相同的接口或者继承相同的抽象类。

	```java
	package proxy;
	/*
	 * 行驶接口
	 */
	public interface Movable {
		void move();
	}
	```

**没用代理**

	```java
	package proxy;
	import java.util.Random;
	/*
	 * 汽车类
	 */
	public class Car implements Movable {
		@Override
		public void move() {
			long startTime = System.currentTimeMillis();
			System.out.println("汽车开始行驶...");
			
			try {
				System.out.println("汽车行驶中...");
				Thread.sleep(new Random().nextInt(1000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			long endTime=System.currentTimeMillis();
			System.out.println("汽车行驶结束...");
			System.out.println("汽车行驶时长："+(endTime-startTime)+"ms");
		}
	}
	```

-

	```java
	package proxy;
	import java.util.Random;
	/*
	 * 汽车类
	 */
	public class Car implements Movable {
		@Override
		public void move() {
			System.out.println("汽车开始行驶...");
			try {
				System.out.println("汽车行驶中...");
				Thread.sleep(new Random().nextInt(1000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println("汽车行驶结束...");
		}
	}
	```

**用继承方式实现静态代理**

	```java
	package proxy;
	/*
	 * Car2 继承 Car
	 */
	public class Car2 extends Car{
		@Override
		public void move() {
			long startTime = System.currentTimeMillis();
			super.move();//用 Car 的  move 方法，实现对 Car的代理 
			long endTime=System.currentTimeMillis();
			System.out.println("汽车行驶时长："+(endTime-startTime)+"ms");
		}
	}
	```

**用聚合方式实现静态代理**

	```java
	package proxy;
	public class Car3 implements Movable {
		private Car car;
		public Car3(Car car) {
			super();
			this.car = car;
		}
		@Override
		public void move() {
			long startTime = System.currentTimeMillis();
			car.move();//用 Car 的  move 方法，实现对 Car的代理 
			long endTime=System.currentTimeMillis();
			System.out.println("汽车行驶时长："+(endTime-startTime)+"ms");
		}
	}
	```

**聚合方式功能叠加**

	```java
	package proxy;
	/*
	 * 时间代理
	 */
	public class CarTimeProxy implements Movable {
		private Movable m;
		public CarTimeProxy(Movable m) {
			super();
			this.m = m;
		}
		@Override
		public void move() {
			System.out.println("汽车开始行驶...");
			long startTime = System.currentTimeMillis();
			m.move();
			long endTime=System.currentTimeMillis();
			System.out.println("汽车行驶结束...");
			System.out.println("汽车行驶时长："+(endTime-startTime)+"ms");
		}
	}
	```

-

	```java
	package proxy;
	/*
	 * 日志代理
	 */
	public class CarLogProxy implements Movable {
		private Movable m;
		public CarLogProxy(Movable m) {
			super();
			this.m = m;
		}
		@Override
		public void move() {
			System.out.println("日志开始...");
			m.move();//用 Car 的  move 方法，实现对 Car的代理 
			System.out.println("日志结束...");
		}
	}
```

-

	```java
	package proxy;
	/*
	 * 测试类
	 */
	public class Test {
		public static void main(String[] args) {		
			// 先记录日志
			//Car car = new Car();
			//CarTimeProxy ctp = new CarTimeProxy(car);
			//CarLogProxy clp = new CarLogProxy(ctp);
			//clp.move();
			// 先记录时间
			Car car = new Car();
			CarLogProxy clp = new CarLogProxy(car);
			CarTimeProxy ctp = new CarTimeProxy(clp);
			ctp.move();
		}
	}
	```

## JDK 动态代理 ##

- 动态代理：动态产生代理，实现对不同类，不同方法的代理

java 动态代理类位于 java.lang.reflect 包下，一般主要涉及到以下两个类

1. Interface InvocationHandler:该接口中仅定义了一个方法。public object invoke(Object obj,Method method,Onject[] args)实际使用时，第一个参数 obj 一般是指代理类，method 是被代理的方法,args 为该方法的参数数组。这个抽象方法在代理类中被动态实现。
2. Proxy:该类即为动态代理的类 static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h):返回代理类的一个实例，返回后代理类可以当作被代理类使用（可使用被代理类的在接口中声明过的方法）。
3. 
所谓 Dynamic Proxy 是这样一种 class:

它是运行时生成的class

该class 需要实现一组 interface

使用动态代理类时，必须实现 InvocationHandler 接口

- 步骤
1. 创建一个实现接口 InvocationHandler 的类，它必须实现 invoke 方法
2. 创建被代理类以及接口
3. 调用 Proxy 的静态方法，创建一个代理类newProxyInstance(ClassLoader loader,Class[] interfaces, InvocationHandler h)。
4. 通过代理调用方法。

举例

	```java
	package jdkproxy;
	/*
	 * 行驶接口
	 */
	public interface Movable {
		void move();
	}
	```

-

	```java
	package jdkproxy;
	import java.util.Random;
	/*
	 * 汽车类
	 */
	public class Car implements Movable {
		public void move() {
			try {
				System.out.println("汽车行驶中...");
				Thread.sleep(new Random().nextInt(1000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	```

-

	```java
	package jdkproxy;
	import java.lang.reflect.InvocationHandler;
	import java.lang.reflect.Method;
	/*
	 * 时间代理
	 */
	public class TimerHandler implements InvocationHandler {
		private Object target;
		public TimerHandler(Object target) {
			super();
			this.target = target;
		}
		/*
		 * 参数：
		 * proxy 被代理对象
		 * method 被代理对象的方法
		 * args 方法的参数
		 * 返回值
		 * Object 方法的返回值
		 */
		public Object invoke(Object proxy, Method method, Object[] args)
				throws Throwable {
			System.out.println("汽车开始行驶...");
			long startTime = System.currentTimeMillis();
			method.invoke(target,null);
			long endTime=System.currentTimeMillis();
			System.out.println("汽车行驶结束...");
			System.out.println("汽车行驶时长："+(endTime-startTime)+"ms");
			return null;
		}
	}
	```

-

	```java
	package jdkproxy;
	import java.lang.reflect.InvocationHandler;
	import java.lang.reflect.Method;
	/*
	 * 日志代理
	 */
	public class LogHandler implements InvocationHandler {
		private Object target;
		public LogHandler(Object target) {
			super();
			this.target = target;
		}
		/*
		 * 参数：
		 * proxy 被代理对象
		 * method 被代理对象的方法
		 * args 方法的参数
		 * 返回值
		 * Object 方法的返回值
		 */
		public Object invoke(Object proxy, Method method, Object[] args)
				throws Throwable {
			System.out.println("开始记录日志...");
			method.invoke(target,null);
			System.out.println("日志记录完毕...");
			return null;
		}
	}
	```

-

	```java
	package jdkproxy;
	import java.lang.reflect.InvocationHandler;
	import java.lang.reflect.Proxy;
	import proxy.Car;
	import proxy.Movable;
	/*
	 * JDK 动态代理测试类
	 */
	public class Test {
		public static void main(String[] args) {
			Car car = new Car();
			Class cls = car.getClass();
			/*
			 * loader 类加载器 interfaces 实现接口 h InvocationHandler
			 */
			// 先记录日志，后记录时间
			// InvocationHandler handler=new TimerHandler(car);
			// Movable m=(Movable)Proxy.newProxyInstance(cls.getClassLoader(),
			// cls.getInterfaces(), handler);
			// InvocationHandler handler1=new LogHandler(m);
			// Movable m1=(Movable)Proxy.newProxyInstance(cls.getClassLoader(),
			// cls.getInterfaces(), handler1);
			// m1.move();
			// 先记录时间，后记录日志
			InvocationHandler handler = new LogHandler(car);
			Movable m = (Movable) Proxy.newProxyInstance(cls.getClassLoader(),
					cls.getInterfaces(), handler);
			InvocationHandler handler1 = new TimerHandler(m);
			Movable m1 = (Movable) Proxy.newProxyInstance(cls.getClassLoader(),
					cls.getInterfaces(), handler1);
			m1.move();
		}
	}
	```

## 使用 cglib 动态产生代理 ##

	```java
	package cglib;
	/*
	 * 火车类
	 */
	public class Train {
		public void move() {
			System.out.println("火车行驶中...");
		}
	}
	```

-

	```java
	package cglib;
	import java.lang.reflect.Method;
	import net.sf.cglib.proxy.Enhancer;
	import net.sf.cglib.proxy.MethodInterceptor;
	import net.sf.cglib.proxy.MethodProxy;
	public class CglibProxy implements MethodInterceptor {
		
		private Enhancer enhancer=new Enhancer();
		public Object getProxy(Class clazz) {
			enhancer.setSuperclass(clazz);
			enhancer.setCallback(this);
			return enhancer.create();
		}
		
		/*
		 * 拦截所有目标类方法的调用
		 * obj 目标类的实例
		 * m 目标方法的反射对象
		 * args 方法的参数
		 * proxy 代理类的实例
		 */
		public Object intercept(Object obj, Method m, Object[] args,
				MethodProxy proxy) throws Throwable {
			System.out.println("日志开始...");
			//代理类调用父类的方法
			proxy.invokeSuper(obj, args);
			System.out.println("日志结束...");
			return null;
		}
	}
	```

-

	```java
	package cglib;
	/*
	 * 测试类
	 */
	public class Test {
	public static void main(String[] args) {
		CglibProxy proxy=new CglibProxy();
		//返回代理类的对象
		Train train = (Train) proxy.getProxy(Train.class);
		train.move();
	}
	}
	```

## JDK 与 CGLIB 的区别 ##
- JDK动态代理
1. 只能代理实现了接口的类
2. 没有实现接口的类不能实现 JDK 的动态代理
- CGLI动态代理
1. 针对类来实现代理的
2. 对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用。
