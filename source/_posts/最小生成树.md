---
title: 最小生成树
date: 2017-09-12 22:20:02
tags: [数据结构,C++]
---
图的应用之最小生成树,普里姆(Prim)算法和克鲁斯卡尔（Kruskal）算法。
<!-- more -->

## 最小生成树

<center>
	<img src="./u.png" width="500px">
</center>
<center>
图1 最小生成树
</center>

## 普里姆(Prim)算法

<center>
	<img src="./v.png" width="500px">
</center>

<center>
	<img src="./w.png" width="500px">
</center>

<center>
	<img src="./x.png" width="500px">
</center>

<center>
	<img src="./y.png" width="500px">
</center>

<center>
	<img src="./z.png" width="500px">
</center>

## 克鲁斯卡尔（Kruskal）算法

<center>
	<img src="./1.png" width="500px">
</center>

<center>
	<img src="./2.png" width="500px">
</center>

<center>
	<img src="./3.png" width="500px">
</center>

<center>
	<img src="./4.png" width="500px">
</center>

<center>
	<img src="./5.png" width="500px">
</center>

## 编码实现

node.h

	```c++
	#pragma once
	class Node
	{
	public:
		Node(char data=0);//构造函数，data 是数据值
		char m_cData;//数据值
		bool m_bIsVisited;//当前节点是否被访问过
	};
	```
node.cpp

	```c++
	#include "Node.h"
	Node::Node(char data)
	{
		m_cData=data;
		m_bIsVisited=false;
	}
	```
Edge.h

	```c++
	#pragma once
	//边
	class Edge
	{
	public:
		Edge(int nodeIndexA=0,int nodeIndexB=0, int weighValue=0);//构造函数
		Edge::~Edge();//析构函数
		int m_iNodeIndexA;//边起点
		int m_iNodeIndexB;//边终点
		int m_iWeighValue;//权值
		bool m_bSelected;//是否已经选择
	};
	```
Edge.cpp

	```c++
	#include "Edge.h"
	//构造函数
	Edge::Edge(int nodeIndexA,int nodeIndexB, int weighValue)
	{
		m_iNodeIndexA=nodeIndexA;
		m_iNodeIndexB=nodeIndexB;
		m_iWeighValue=weighValue;
		m_bSelected=false;
	}
	//析构函数
	Edge::~Edge()
	{
	}
	```

Map.h

	```c++
	#pragma once
	#include <stdio.h>
	#include <vector>
	using namespace std;
	#include "Node.h"
	#include "Edge.h"
	//图 普利姆算法
	class Map
	{
	public:
		Map(int capacity);//构造函数
		~Map();//析构函数
		bool addNode(Node *pNode);//向图中加入顶点（节点）
		void resetNode();//重置顶点
		bool setValueToMatrixForDirectedGraph(int row,int col,int val = 1);//为有向图设置邻接矩阵
		bool setValueToMatrixForUndirectedGraph(int row,int col,int val=1);//为无向图设置邻接矩阵
		void printMatrix();//打印邻接矩阵
		void depthFirstTraverse(int nodeIndex);//深度优先遍历
		void breadthFirstTraverse(int nodeIndex);//广度优先遍历
		void primTree(int nodeIndex);//普里姆算法
		void kruskalTree();//克鲁斯卡尔算法
	private:
		bool getValueFromMatrix(int row,int col,int &val);//从矩阵中获取权值
		void breadthFirstTraverseImpl(vector<int> preVec);//广度优先遍历实现函数
		int getMinEdge(vector<Edge> edgeVec);//从可选边集合中找到权值最小的边
		bool isInSet(vector<int> nodeSet,int taeget);//判断顶点是否在点集合中
		void mergeNodeSet(vector<int>&nodeA,vector<int>nodeB);//合并两个顶点集合
	private:
		int m_iCapacity;//图中最多可以容纳的顶点数
		int m_iNodeCount;//已经添加的顶点（节点）个数
		Node *m_pNodeArray;//用来存放顶点的数组
		int *m_pMatrix;//用来存放邻接矩阵
		Edge *m_pEdge;//边数组
	};

	```
Map.cpp

	```c++
	#include "Map.h"
	#include<iostream>
	#include <vector>
	using namespace std;
	//构造函数
	Map::Map(int capacity)
	{
		m_iCapacity=capacity;
		m_iNodeCount=0;
		m_pNodeArray=new Node[m_iCapacity];//顶点
		m_pMatrix=new int[m_iCapacity*m_iCapacity];//邻接矩阵
		m_pEdge=new Edge[m_iCapacity];//最小生成树边数=节点数 n-1
		//临街矩阵初始化
		memset(m_pMatrix,0,m_iCapacity*m_iCapacity*sizeof(int));
	}
	//析构函数
	Map::~Map()
	{
		if (m_pNodeArray!=NULL)
		{
			delete []m_pNodeArray;
			m_pNodeArray=NULL;
		}
		if (m_pMatrix!=NULL)
		{
			delete []m_pMatrix;
			m_pMatrix=NULL;
		}
		if (m_pEdge!=NULL)
		{
			delete []m_pEdge;
			m_pEdge=NULL;
		}
	}
	//向图中加入顶点（节点）
	bool Map::addNode(Node *pNode)
	{
		if (pNode==NULL)
		{
			return false;
		}
		m_pNodeArray[m_iNodeCount].m_cData=pNode->m_cData;
		m_iNodeCount++;
		return true;
	}
	//重置顶点
	void Map::resetNode()
	{
		for (int i=0;i<m_iNodeCount;i++)
		{
			m_pNodeArray[i].m_bIsVisited=false;
		}
	}
	//为有向图设置邻接矩阵
	bool Map::setValueToMatrixForDirectedGraph(int row,int col,int val)
	{
		if(row<0&&row>=m_iCapacity)
		{
			return false;
		}
		if(col<0&&col>=m_iCapacity)
		{
			return false;
		}
		m_pMatrix[row*m_iCapacity+col]=val;
		return true;
	}
	//为无向图设置邻接矩阵
	bool Map::setValueToMatrixForUndirectedGraph(int row,int col,int val)
	{
		if(row<0&&row>=m_iCapacity)
		{
			return false;
		}
		if(col<0&&col>=m_iCapacity)
		{
			return false;
		}
		m_pMatrix[row*m_iCapacity+col]=val;
		m_pMatrix[col*m_iCapacity+row]=val;
		return true;
	}
	//从矩阵中获取权值
	bool Map::getValueFromMatrix(int row,int col,int &val)
	{
		if(row<0&&row>=m_iCapacity)
		{
			return false;
		}
		if(col<0&&col>=m_iCapacity)
		{
			return false;
		}
		val=m_pMatrix[row*m_iCapacity+col];
		return true;
	}
	//打印邻接矩阵
	void Map::printMatrix()
	{
		for (int i=0;i<m_iCapacity;i++)
		{
			for (int k=0;k<m_iCapacity;k++)
			{
				cout<<m_pMatrix[i*m_iCapacity+k]<<" ";
			}
			cout<<endl;
		}
	}
	//深度优先遍历
	void Map::depthFirstTraverse(int nodeIndex)
	{
		int value=0;
		//先访问当前节点
		cout<<m_pNodeArray[nodeIndex].m_cData<<" ";
		m_pNodeArray[nodeIndex].m_bIsVisited=true;
		//通过邻接矩阵判断是否与其他的顶点有连接
		for (int i=0;i<m_iCapacity;i++)
		{
			getValueFromMatrix(nodeIndex,i,value);
			//判断是否有弧连接其他顶点
			if(value!=0)
			{
				//在判断该点是否被访问过
				if (m_pNodeArray[i].m_bIsVisited)
				{
					continue;
				} 
				else
				{
					depthFirstTraverse(i);
				}
			}else//如果没有去向索引为 i 的顶点的弧，则循环继续
			{
				continue;
			}
		}
	}
	//广度优先遍历
	void Map::breadthFirstTraverse(int nodeIndex)
	{
		//先访问当前节点
		cout<<m_pNodeArray[nodeIndex].m_cData<<" ";
		m_pNodeArray[nodeIndex].m_bIsVisited=true;
		vector<int> curVec;//使用标准模板库中的数组
		curVec.push_back(nodeIndex);
		breadthFirstTraverseImpl(curVec);
	}
	//广度优先遍历实现函数
	void Map::breadthFirstTraverseImpl(vector<int> preVec)
	{
		int value=0;
		vector<int> curVec;
		//遍历上一层节点
		for (int j=0;j<int(preVec.size());j++)
		{
			//遍历上一层的一个节点与其他节点是否有连接
			for (int i=0;i<m_iCapacity;i++)
			{
				getValueFromMatrix(preVec[j],i,value);
				//判断是否有弧连接其他顶点
				if(value!=0)
				{
					//在判断该点是否被访问过
					if (m_pNodeArray[i].m_bIsVisited)
					{
						continue;
					} 
					else
					{
						//先访问当前节点
						cout<<m_pNodeArray[i].m_cData<<" ";
						m_pNodeArray[i].m_bIsVisited=true;
						curVec.push_back(i);
					}
				}
			}
		}
		//判断下一层是否为空层
		if (curVec.size()==0)
		{
			return;
		}else
		{
			breadthFirstTraverseImpl(curVec);
		}
	}
	//普里姆算法
	void Map::primTree(int nodeIndex)
	{
		int value = 0;//权值
		int edgeCount=0;//边数
		vector<int> nodeVec;//点
		vector<Edge>edgeVec;//边
		//打印当前节点
		cout<<m_pNodeArray[nodeIndex].m_cData<<endl;
		//存入节点数组
		nodeVec.push_back(nodeIndex);
		m_pNodeArray[nodeIndex].m_bIsVisited=true;
		//边数等于 (点数-1)
		while(edgeCount<m_iCapacity-1)
		{
			int temp = nodeVec.back();//取出nodeVec中最后一个元素。
			for (int i=0;i<m_iCapacity;i++)
			{
				getValueFromMatrix(temp,i,value);
				//判断是否有边连接
				if (value!=0)
				{
					//判断是否被访问过,不会放重复的边
					if (m_pNodeArray[i].m_bIsVisited)
					{
						continue;
					} 
					else
					{
						Edge edge(temp,i,value);
						edgeVec.push_back(edge);
					}
				} 
			}
			//从可选边集合中找到权值最小的边
			int edgeIndex = getMinEdge(edgeVec);
			//标记边被选择了
			edgeVec[edgeIndex].m_bSelected=true;
			//打印最小边
			cout<<edgeVec[edgeIndex].m_iNodeIndexA<<"---"<<edgeVec[edgeIndex].m_iNodeIndexB;
			//打印权值
			cout<<"("<<edgeVec[edgeIndex].m_iWeighValue<<")"<<endl;
			m_pEdge[edgeIndex]=edgeVec[edgeIndex];
			edgeCount++;
			//找到与当前最小边所连接的那个点
			int nextNodeIndex=edgeVec[edgeIndex].m_iNodeIndexB;
			nodeVec.push_back(nextNodeIndex);
			//标记点被选择了
			m_pNodeArray[nextNodeIndex].m_bIsVisited=true;
			//打印下一个节点
			cout<<m_pNodeArray[nextNodeIndex].m_cData<<endl;
		}
	}
	//从可选边集合中找到权值最小的边
	int Map::getMinEdge(vector<Edge> edgeVec)
	{
		int minWeight = 0;//保存最小权值
		int edgeIndex = 0;//最小权值边的索引
		int i=0;
		for (;i<(int)edgeVec.size();i++)
		{
			//判断边是否被选出来过
			if (!edgeVec[i].m_bSelected)
			{
				minWeight=edgeVec[i].m_iWeighValue;
				edgeIndex=i;
				break;
			}
		}
		//判断是否都被选择过
		if (minWeight==0)
		{
			return -1;
		}
		//判断剩余的边中是否有最小边。
		for (;i<(int)edgeVec.size();i++)
		{
			if (edgeVec[i].m_bSelected)
			{
				continue;
			}
			else
			{
				if (minWeight>edgeVec[i].m_iWeighValue)
				{
					minWeight=edgeVec[i].m_iWeighValue;
					edgeIndex=i;
				}
			}
		}
		return edgeIndex;
	}
	//克鲁斯卡尔算法
	void Map::kruskalTree()
	{
		int value = 0;//权值
		int edgeCount=0;//边数
		//定义存放点集合的数组
		vector<vector<int>> nodeSets;//点
		//一：取出所有边
		vector<Edge>edgeVec;//边
		//邻接矩阵上三角不含主对角线
		for (int i=0;i<m_iCapacity;i++)
		{
			for (int k=i;k<m_iCapacity;k++)
			{
				getValueFromMatrix(i,k,value);
				if (value!=0)
				{
					Edge edge(i,k,value);
					edgeVec.push_back(edge);
				}
			}
		}
		//二：从所有边中取出组成最小生成树的边
		//1.算法结束条件
		while (edgeCount<m_iCapacity-1)
		{
			//2.从集合中找到最小边
			int minEdgeIndex=getMinEdge(edgeVec);
			edgeVec[minEdgeIndex].m_bSelected=true;
			//3.找出最小边连接的点
			int nodeAIndex=edgeVec[minEdgeIndex].m_iNodeIndexA;
			int nodeBIndex=edgeVec[minEdgeIndex].m_iNodeIndexB;
			//4.找出点所在的点集合
			bool nodeAIsInSet=false;//nodeA 是否在集合中
			bool nodeBIsInSet=false;//nodeB 是否在集合中
			int nodeAInSetLabel=-1;//nodeA 所在集合的索引
			int nodeBInSetLabel=-1;//nodeB 所在集合的索引
			//找 nodeA 所在集合的索引
			for (int i=0;i<(int)nodeSets.size();i++)
			{
				nodeAIsInSet=isInSet(nodeSets[i],nodeAIndex);
				if (nodeAIsInSet)
				{
					nodeAInSetLabel=i;
				}
			}
			//找 nodeB 所在集合的索引
			for (int i=0;i<(int)nodeSets.size();i++)
			{
				nodeBIsInSet=isInSet(nodeSets[i],nodeBIndex);
				if (nodeBIsInSet)
				{
					nodeBInSetLabel=i;
				}
			}
			//5.根据点所在集合的不同做出不同的处理
			//如果 nodeA 和 nodeB 都不在集合中
			if (nodeAInSetLabel==-1&&nodeBInSetLabel==-1)
			{
				//新建一个集合
				vector<int> vec;
				vec.push_back(nodeAIndex);
				vec.push_back(nodeBIndex);
				nodeSets.push_back(vec);
			}
			//如果 nodeA 都不在集合中 nodeB 在某一个集合中
			else if (nodeAInSetLabel==-1&&nodeBInSetLabel!=-1)
			{
				//将 nodeA 放到 nodeB 所在的点集合中
				nodeSets[nodeBInSetLabel].push_back(nodeAIndex);
			}
			//如果 nodeA 在某一个集合中 nodeB 都不在集合中
			else if (nodeAInSetLabel!=-1&&nodeBInSetLabel==-1)
			{
				//将 nodeB 放到 nodeA 所在的点集合中
				nodeSets[nodeAInSetLabel].push_back(nodeBIndex);
			}
			//如果 nodeA nodeB 在不同集合中
			else if (nodeAInSetLabel!=-1&&nodeBInSetLabel!=-1&&nodeAInSetLabel!= nodeBInSetLabel)
			{
				//合并两个集合，合并到第一个集合
				mergeNodeSet(nodeSets[nodeAInSetLabel],nodeSets[nodeBInSetLabel]);
				//后边的集合向前移一位，消除后一个
				for (int k=nodeBInSetLabel;k<(int)nodeSets.size()-1;k++)
				{
					nodeSets[k]=nodeSets[k+1];
				}
			}
			//如果 nodeA nodeB 在相同集合中
			else if (nodeAInSetLabel!=-1&&nodeBInSetLabel!=-1&&nodeAInSetLabel== nodeBInSetLabel)
			{
				continue;
			}
			//保存最小边
			m_pEdge[edgeCount]=edgeVec[minEdgeIndex];
			edgeCount++;
			cout<<edgeVec
				//打印最小边
				[minEdgeIndex].m_iNodeIndexA<<"---"<<edgeVec[minEdgeIndex].m_iNodeIndexB<<"("<<edgeVec[minEdgeIndex].m_iWeighValue<<")"<<endl;
		}
	}
	//判断顶点是否在点集合中
	bool Map::isInSet(vector<int> nodeSet,int taeget)
	{
		for (int i=0;i<(int)nodeSet.size();i++)
		{
			if (nodeSet[i]==taeget)
			{
				return true;
			}
		}
		return false;
	}
	//合并两个顶点集合
	void Map::mergeNodeSet(vector<int>&nodeA,vector<int>nodeB)
	{
		for (int i=0;i<(int)nodeB.size();i++)
		{
			nodeA.push_back(nodeB[i]);
		}
	}
	```

demo.cpp

	```c++
	/*
			   A
		    /  |  \
		   B … F … E
		    \ / \  / 
			 C … D
	A B C D E F
	0 1 2 3 4 5
	A-B 6	A-E 5	A-F 1
	B-C 3	B-F 2
	C-F 8	C-D 7
	D-F 4	D-E 2
	E-F 9
	*/
	#include<iostream>
	#include<stdlib.h>
	using namespace std;
	#include "Node.h"
	#include "Map.h"
	int main(void)
	{
		Map *pMap=new Map(6);
		Node *pNodeA=new Node('A');
		Node *pNodeB=new Node('B');
		Node *pNodeC=new Node('C');
		Node *pNodeD=new Node('D');
		Node *pNodeE=new Node('E');
		Node *pNodeF=new Node('F');
		pMap->addNode(pNodeA);
		pMap->addNode(pNodeB);
		pMap->addNode(pNodeC);
		pMap->addNode(pNodeD);
		pMap->addNode(pNodeE);
		pMap->addNode(pNodeF);
		pMap->setValueToMatrixForUndirectedGraph(0,1,6);
		pMap->setValueToMatrixForUndirectedGraph(0,4,5);
		pMap->setValueToMatrixForUndirectedGraph(0,5,1);
		pMap->setValueToMatrixForUndirectedGraph(1,2,3);
		pMap->setValueToMatrixForUndirectedGraph(1,5,2);
		pMap->setValueToMatrixForUndirectedGraph(2,5,8);
		pMap->setValueToMatrixForUndirectedGraph(2,3,7);
		pMap->setValueToMatrixForUndirectedGraph(3,5,4);
		pMap->setValueToMatrixForUndirectedGraph(3,4,2);
		pMap->setValueToMatrixForUndirectedGraph(4,5,9);
		pMap->printMatrix();
		cout<<endl;
		pMap->resetNode();
		pMap->primTree(0);
		cout<<endl;
		pMap->resetNode();
		pMap->kruskalTree();
		cout<<endl;
		delete pMap;
		system("pause");
		return 0;
	}
	```