---
title: 数据结构之树
date: 2017-09-10 16:16:28
tags: [数据结构,C++]
---

树是节点的有限集合。
<!-- more -->

## 树的基本概念

<center>
	<img src="./a.png" width="500px"></img>
</center>
<center>
图1 树定义
</center>

双亲：最顶端的节点（A）是根节点也称为双亲。

孩子：（B）的孩子是（E）、（F）,（A）的孩子是（B）、（C）、（D）。

度：当前节点直接的孩子。（A）的度为 3，(B)的度为 2，（C）的度为 0。

叶子：树的终端节点。（E）、（F）、（C）、（G)、（H）。

根：树的非终端节点。(A)、（B）、（D).

有序树：孩子节点不可以换顺序。无序树：孩子节点可以换顺序。

祖先：指定节点向上到根节点路过的所有节点。(E)的祖先是(B)、(A),(G)的祖先是(D)、(A)

子孙：从指定节点生出的子节点，以及生出节点的子节点，都属于当前节点的子孙。(D)的子孙包括（G）、（H）。(A)的子孙包括其他所有节点。

<center>
	<img src="./b.png" width="500px"></img>
</center>
<center>
图2 树定义
</center>

节点深度：第 n 层的节点深度为 n。

树深度：树中节点所具有的最大深度。这款是深度为 3 。

森林：多棵树组成森林，一棵树也可以看成多棵不同子树组成的子节点。

二叉树：所有节点的度都小于 2。如图3右。

<center>
	<img src="./d.png" width="500px"></img>
</center>
<center>
图2 二叉树
</center>

二叉树的广度优先遍历（BFT）

<center>
	<img src="./e.png" width="500px"></img>
</center>
<center>
图2 树定义
</center>

前序遍历：根左右。中序遍历：左根右。后续遍历：左右根。

树的应用：1 压缩软件-赫夫曼树。2 搜索-人机对战。

## 二叉树的编码实现

二叉树的数组实现编码（int）

tree.h


	```c++
	#pragma once
	//#include <stdio.h>
	//用数组实现二叉树(int)
	//数组与树之间的算法转换
	/*
	int tree[n] 1 2 3 5 7 8 9
	父节点下标*2+1 该节点左
	父节点下标*2+2 该节点右
			1(0)
		2(1)		3(2)
	5(3)	7(4)		8(5)	 9(6)
	*/
	class Tree
	{
	public:
		Tree(int size,int *pRoot);//创建树
		~Tree();//销毁树
		int *SearchNode(int nodeIndex);//根据索引寻找节点
		bool AddNode(int nodeIndex,int direction,int *pNode);//添加节点
		bool DeleteNode(int nodeIndex,int *pNode);//删除节点
		void TreeTraverse();//遍历树
	private:
		int *m_pTree;//指向树的数组指针
		int m_iSize;//数组的大小
	};
	```

tree.cpp

	```c++
	#include <iostream>
	#include "Tree.h"
	using namespace std;
	//创建树 size 树最多能容纳的节点个数
	Tree::Tree(int size,int *pRoot)
	{
		m_iSize=size;
		m_pTree=new int[m_iSize];
		for (int i=0;i<m_iSize;i++)
		{
			m_pTree[i]=-1;//初始值-1
		}
		m_pTree[0]=*pRoot;
	}
	//销毁树
	Tree::~Tree()
	{
		delete []m_pTree;
		m_pTree=NULL;
	}
	//根据索引寻找节点
	int *Tree::SearchNode(int nodeIndex)
	{
		if (nodeIndex<0||nodeIndex>=m_iSize)
		{
			return NULL;
		}
		if (m_pTree[nodeIndex]==-1)
		{
			return NULL;
		}
		return &m_pTree[nodeIndex];
	}
	//添加节点
	bool Tree::AddNode(int nodeIndex,int direction,int *pNode)
	{
		if (nodeIndex<0||nodeIndex>=m_iSize)
		{
			return false;
		}
		if (m_pTree[nodeIndex]==-1)
		{
			return false;
		}
		if (direction==0)//插入左孩子
		{
			if ((nodeIndex*2+1)>=m_iSize)
			{
				return false;
			}
			if (m_pTree[nodeIndex*2+1]!=-1)
			{
				return false;
			}
			m_pTree[nodeIndex*2+1]=*pNode;
		}
		if (direction==1)//插入右孩子
		{
			if ((nodeIndex*2+2)>=m_iSize)
			{
				return false;
			}
			if (m_pTree[nodeIndex*2+2]!=-1)
			{
				return false;
			}
			m_pTree[nodeIndex*2+2]=*pNode;
		}
		return true;
	}
	//删除节点
	bool Tree::DeleteNode(int nodeIndex,int *pNode)
	{
		if (nodeIndex<0||nodeIndex>=m_iSize)
		{
			return false;
		}
		if (m_pTree[nodeIndex]==-1)
		{
			return false;
		}
		*pNode=m_pTree[nodeIndex];
		m_pTree[nodeIndex]=-1;
		return true;
	}
	//遍历树
	void Tree::TreeTraverse()
	{
		for (int i=0;i<m_iSize;i++)
		{
			cout<<m_pTree[i]<<" ";
		}
		cout<<endl;
	}
	```

demo.cpp

	```c++
	#include <stdlib.h>
	#include <iostream>
	#include "Tree.h"
	using namespace std;
	int main(void)
	{
		int root=1;
		Tree *pTree=new Tree(10,&root);
		pTree->TreeTraverse();
		int node1=2;
		int node2=3;
		pTree->AddNode(0,0,&node1);
		pTree->AddNode(0,1,&node2);
		pTree->TreeTraverse();
		int node3=5;
		int node4=7;
		pTree->AddNode(1,0,&node3);
		pTree->AddNode(1,1,&node4);
		pTree->TreeTraverse();
		int node5=8;
		int node6=9;
		pTree->AddNode(2,0,&node5);
		pTree->AddNode(2,1,&node6);
		pTree->TreeTraverse();
		cout<<*(pTree->SearchNode(2))<<endl;
		int pTemp;
		pTree->DeleteNode(2,&pTemp);
		cout<<"temp:"<<pTemp<<endl;
		pTree->TreeTraverse();
		delete pTree;
		system("pause");
		return 0;
	}
	```

二叉树的链表实现编码（int）

Node.h

	```c++
	#pragma once
	#include <stdio.h>
	class Node
	{	
	public:
		Node();//构造函数
		Node *SearchNode(int nodeIndex);//搜索节点
		void DeleteNode();//删除节点
		void PreorTraverse();//前序遍历
		void InorderTraverse();//中序遍历
		void PostorTraverse();//后序遍历
		int index;
		int data;
		Node *pLChild;
		Node *pRChild;
		Node *pParent;
	};
	```

Node.cpp

	```c++
	#include "Node.h"
	#include <iostream>
	using namespace std;
	Node::Node(void)
	{
		index=0;
		data=0;
		pLChild=NULL;
		pRChild=NULL;
		pParent=NULL;
	}
	//搜索节点
	Node *Node::SearchNode(int nodeIndex)
	{
		Node *temp=new Node();
		if (this->index==nodeIndex)
		{
			return this;
		}
		if (this->pLChild!=NULL)
		{
			if (this->pLChild->index==nodeIndex)
			{
				return this->pLChild;
			}else
			{
				temp=this->pLChild->SearchNode(nodeIndex);
				if (temp!=NULL)
				{
					return temp;
				}
			}
		}
		if (this->pRChild!=NULL)
		{
			if (this->pRChild->index==nodeIndex)
			{
				return this->pRChild;
			}
			else
			{
				temp=this->pRChild->SearchNode(nodeIndex);
				if (temp!=NULL)
				{
					return temp;
				}
			}
		}
		return NULL;
	}
	//删除节点
	void Node::DeleteNode()
	{
		if (this->pLChild!=NULL)
		{
			pLChild->DeleteNode();
		}
		if (this->pRChild!=NULL)
		{
			pRChild->DeleteNode();
		}
		if (this->pParent!=NULL)
		{
			if (this->pParent->pLChild==this)
			{
				this->pParent->pLChild=NULL;
			}
			if (this->pParent->pRChild==this)
			{
				this->pParent->pRChild=NULL;
			}
		}
		delete this;
	}
	//前序遍历
	void Node::PreorTraverse()
	{
		cout<<this->index<<":"<<this->data<<endl;
		if (this->pLChild!=NULL)
		{
			this->pLChild->PreorTraverse();
		}
		if (this->pRChild!=NULL)
		{
			this->pRChild->PreorTraverse();
		}
	}
	//中序遍历
	void Node::InorderTraverse()
	{
		if (this->pLChild!=NULL)
		{
			this->pLChild->InorderTraverse();
		}
		cout<<this->index<<":"<<this->data<<endl;
		if (this->pRChild!=NULL)
		{
			this->pRChild->InorderTraverse();
		}
	}
	//后序遍历
	void Node::PostorTraverse()
	{
		if (this->pLChild!=NULL)
		{
			this->pLChild->PostorTraverse();
		}
		if (this->pRChild!=NULL)
		{
			this->pRChild->PostorTraverse();
		}
		cout<<this->index<<":"<<this->data<<endl;
	}
	```

Tree.h

	```c++
	#pragma once
	//#include <stdio.h>
	//二叉树的链表实现(int)
	/*
	节点要素：索引 数据 左孩子指针 右孩子指针 父节点指针
	前序遍历：0 1 3 4 2 5 6
	中序遍历：3 1 4 0 5 2 6
	后序遍历：3 4 1 5 6 2 0
			(0)
		2(1)		3(2)
	5(3)	7(4)		8(5)	 9(6)
	*/
	#include "Node.h"
	class Tree
	{
	public:
		Tree();	//创建树
		~Tree();					//销毁树
		Node *SearchNode(int nodeIndex);//搜索节点
		bool AddNode(int nodeIndex,int direction,Node *pNode);//添加节点
		bool DeleteNode(int nodeIndex,Node *pNode);//删除节点
		void PreorTraverse();//前序遍历
		void InorderTraverse();//中序遍历
		void PostorTraverse();//后序遍历
	private:
		Node *m_pRoot;//指向树的根节点指针
	};
	```

tree.cpp

	```c++
	#include <iostream>
	#include "Tree.h"
	using namespace std;
	//构造函数 创建树
	Tree::Tree()
	{
		m_pRoot=new Node();
	}
	//析构函数 销毁树
	Tree::~Tree()
	{
		//DeleteNode(0,NULL);
		m_pRoot->DeleteNode();
	}
	//根据索引寻找节点
	Node *Tree::SearchNode(int nodeIndex)
	{
		return m_pRoot->SearchNode(nodeIndex);
	}
	//添加节点
	bool Tree::AddNode(int nodeIndex,int direction,Node *pNode)
	{
		Node *temp=SearchNode(nodeIndex);
		if (temp==NULL)
		{
			return false;
		}
		Node *node=new Node();//一定要新从堆中申请
		if(node==NULL)
		{
			return false;
		}
		node->data=pNode->data;
		node->index=pNode->index;
		node->pParent=temp;
		if(direction==0)//挂在左
		{
			temp->pLChild=node;
		}
		if(direction==1)//挂在右
		{
			temp->pRChild=node;
		}
		return true;
	}
	//删除节点
	bool Tree::DeleteNode(int nodeIndex,Node *pNode)
	{
		Node *temp=SearchNode(nodeIndex);
		if (temp==NULL)
		{
			return false;
		}
		if (pNode!=NULL)
		{
			pNode->data=temp->data;
		}
		temp->DeleteNode();
		return true;
	}
	//前序遍历树
	void Tree::PreorTraverse()
	{
		m_pRoot->PreorTraverse();
	}
	//中序遍历树
	void Tree::InorderTraverse()
	{
		m_pRoot->InorderTraverse();
	}
	//后序遍历树
	void Tree::PostorTraverse()
	{
		m_pRoot->PostorTraverse();
	}
	```

demo.cpp

	```c++
	#include <stdlib.h>
	#include <iostream>
	#include "Tree.h"
	using namespace std;
	/*
	前序遍历：0 1 3 7 8 4 2 5 6
	中序遍历：7 3 8 1 4 0 5 2 6
	后序遍历：7 8 3 4 1 5 6 2 0
					(0)
			2(1)			3(2)
		5(3)	7(4)		8(5)	 9(6)
	10(7)	11(8)
	*/
	int main(void)
	{
		Tree *tree=new Tree();
		Node *node1=new Node();
		node1->index=1;
		node1->data=2;
		Node *node2=new Node();
		node2->index=2;
		node2->data=3;
		Node *node3=new Node();
		node3->index=3;
		node3->data=5;
		Node *node4=new Node();
		node4->index=4;
		node4->data=7;
		Node *node5=new Node();
		node5->index=5;
		node5->data=8;
		Node *node6=new Node();
		node6->index=6;
		node6->data=9;
		Node *node7=new Node();
		node7->index=7;
		node7->data=10;
		Node *node8=new Node();
		node8->index=8;
		node8->data=11;
		tree->AddNode(0,0,node1);
		tree->AddNode(0,1,node2);
		tree->AddNode(1,0,node3);
		tree->AddNode(1,1,node4);
		tree->AddNode(2,0,node5);
		tree->AddNode(2,1,node6);
		tree->AddNode(3,0,node7);
		tree->AddNode(3,1,node8);
		tree->DeleteNode(6,NULL);
		//tree->DeleteNode(1,NULL);
		tree->PreorTraverse();
		cout<<endl;
		cout<<tree->SearchNode(8)->index<<":"<<tree->SearchNode(8)->data<<endl;
		cout<<endl;
		tree->DeleteNode(7,NULL);
		tree->PreorTraverse();
		cout<<endl;
		//tree->InorderTraverse();
		//cout<<endl;
		//tree->PostorTraverse();
		//cout<<endl;
		delete tree;
		system("pause");
		return 0;
	}
	```